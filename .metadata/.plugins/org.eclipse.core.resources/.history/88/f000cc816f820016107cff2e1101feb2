package ocdSim;

/*a class that represents an object that can appear in the overworld.*/
public abstract class OverworldObject extends PComponent {

	private PVector pos, dim;
	private  float checkRadius;
	private  PVector absoluteTranslation; //sum of the translations from upper left corner of all the object's enclosing objects (i.e., the gameworld and the moveable npc map). for use in the collision checks.

	  /* variables controlling the rotation parameters of the gameobjects. gameobjects have the ability to turn towards a target*/
	private  PVector quaternion;
	private  float targetAngleY;
	private float dAngleY=radians(1);
	private float yAngleGive=radians(1);

	 public GameObject(PVector pos, PVector dim, float parentTranslationX, float parentTranslationZ, float checkRadius, PVector quaternion) {
	    this.pos=pos;
	    this.dim=dim;
	    this.checkRadius=checkRadius;
	    absoluteTranslation=pos.get();
	    this.quaternion=quaternion;
	    updatePerceivedTranslation(parentTranslationX, parentTranslationZ);
	  }

	 public PVector absoluteTranslation() {
	    return absoluteTranslation;
	  }

	  void turnTowards(float angle) {
	    targetAngleY=angle;
	  }

	  /* GameObjects only exist within the game world*/
	  public abstract void handleCollisionWithPlayer();

	  public void updatePerceivedTranslation(float parentTranslationX, float parentTranslationZ) {
	    absoluteTranslation.x=pos.x+parentTranslationX;
	    absoluteTranslation.z=pos.z+parentTranslationZ;
	  }

	  public float checkRadius() {
	    return checkRadius;
	  }


	  public void render() {
	  }

	  public void update() {
	    turnTowardsTarget();
	    draw();
	  }


	  protected void turnTowardsTarget() {
	    if (abs(targetAngleY-quaternion.y)>yAngleGive) {
	      if (targetAngleY>quaternion.y) {
	        dAngleY=abs(dAngleY);
	      } else {
	        dAngleY=-abs(dAngleY);
	      }
	      quaternion.y+=dAngleY;
	    }
	  }

	  private void draw() {
	    pushMatrix();
	    pushStyle();
	    translate(pos);
	    rotate(quaternion);
	    render();
	    popStyle();
	    popMatrix();
	  }
}
