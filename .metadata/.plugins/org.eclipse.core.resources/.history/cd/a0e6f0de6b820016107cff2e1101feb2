/*an enum like class that will be used to represent all of the different possible types of food that can encoutered in the game. 
 each instance will remember the persistent data that is particular to it */
class FoodType {
  ArrayList<Concern> concerns=new ArrayList<Concern>(); //the concerns that apply to this type of food
  String label; //the label for this type of food
  String requestToEat; //each food can remember a special message requesting the player to eat it
  PImage img; //this food's image
  float energyProvided; //the amount of energy this food provides if it's eaten


  FoodType(PImage img, String label, String requestToEat) {
    this.img=img;
    this.label=label;
    this.requestToEat=requestToEat;
  }

  String getLabel() {
    return label;
  }

  PImage getImage() {
    return img;
  }

  void addConcern(Concern concern) {
    concerns.add(concern);
  }

  ArrayList<Concern> getConcerns() {
    return concerns;
  }

  void setEnergy(float energy) {
    this.energyProvided=energy;
  }
  float getEnergy() {
    return energyProvided;
  }

  String getRequestToEat() {
    return requestToEat;
  }
}



/*a class that represents the data for a particular Food Object */
class FoodObjectData {
  FoodType type; //the type of food that this food object is
  Map<Concern, Boolean> concerns=new HashMap<Concern, Boolean>(); //the results of each check on each concern

  FoodObjectData(FoodType type) {
    this.type=type;
    for (Concern concern : type.getConcerns()) {
      concerns.put(concern, null);
    }
  }
  
  float getEnergy(){
    return type.getEnergy();
    
  }
  
  String getLabel(){
   return type.getLabel();
  }
  
  String getRequestToEat(){
    return type.getRequestToEat();
  }
  
  ArrayList<Concern> getConcerns(){
    return type.getConcerns();
  }
  
  PImage getImage(){
    return type.getImage();
  }

  void storeResultOfCheck(Concern concern, boolean result) {
    concerns.put(concern, new Boolean(result));
  }

  boolean getResultFor(Concern concern) {
    Boolean result=concerns.get(concern);
    return result.booleanValue();
  }

  boolean hasResultFor(Concern concern) {
    return concerns.get(concern)!=null;
  }
}