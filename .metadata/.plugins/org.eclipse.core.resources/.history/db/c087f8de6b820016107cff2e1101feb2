EventTriggerGenerator CONCERN=new EventTriggerGenerator();
JewelGenerator JEWEL=new JewelGenerator();
FoodGenerator FOOD=new FoodGenerator();

class ObjectGenerator {

  GameObject generate(PVector pos, PVector dim, float parentTranslationX, float parentTranslationZ, float checkRadius, PVector quaternion) {
    return null;
  }
}

class FoodGenerator extends ObjectGenerator {
  GameObject generate(PVector pos, PVector dim, float parentTranslationX, float parentTranslationZ, float checkRadius, PVector quaternion) {
    dim.y=dim.x;
    return new FoodObject(pos, dim, parentTranslationX, parentTranslationZ, checkRadius, quaternion, new FoodObjectData(getFoodType()));
  }
}



class EventTriggerGenerator extends ObjectGenerator {
  GameObject generate(PVector pos, PVector dim, float parentTranslationX, float parentTranslationZ, float checkRadius, PVector quaternion) {
    dim.y=dim.x;
    return new ConcernTrigger(pos, dim, parentTranslationX, parentTranslationZ, checkRadius, quaternion);
  }
}



class JewelGenerator extends ObjectGenerator {

  GameObject generate(PVector pos, PVector dim, float parentTranslationX, float parentTranslationZ, float checkRadius, PVector quaternion) {
    dim.y=dim.x;
    return new Jewel(pos, dim, parentTranslationX, parentTranslationZ, checkRadius, quaternion);
  }
}

class GameObject {

  PVector pos, dim;
  float checkRadius;
  PVector absoluteTranslation; //sum of the translations from upper left corner of all the object's enclosing objects (i.e., the gameworld and the moveable npc map). for use in the collision checks.

  /* variables controlling the rotation parameters of the gameobjects. gameobjects have the ability to turn towards a target*/
  PVector quaternion;
  float targetAngleY;
  float dAngleY=radians(1);
  float yAngleGive=radians(1);

  GameObject(PVector pos, PVector dim, float parentTranslationX, float parentTranslationZ, float checkRadius, PVector quaternion) {
    this.pos=pos;
    this.dim=dim;
    this.checkRadius=checkRadius;
    absoluteTranslation=pos.get();
    this.quaternion=quaternion;
    updatePerceivedTranslation(parentTranslationX, parentTranslationZ);
  }

  PVector absoluteTranslation() {
    return absoluteTranslation;
  }

  void turnTowards(float angle) {
    targetAngleY=angle;
  }

  /* GameObjects only exist within the game world*/
  void handleCollisionWithPlayer() {
  }

  void updatePerceivedTranslation(float parentTranslationX, float parentTranslationZ) {
    absoluteTranslation.x=pos.x+parentTranslationX;
    absoluteTranslation.z=pos.z+parentTranslationZ;
  }

  float checkRadius() {
    return checkRadius;
  }


  void render() {
  }

  void update() {
    turnTowardsTarget();
    draw();
  }


  void turnTowardsTarget() {
    if (abs(targetAngleY-quaternion.y)>yAngleGive) {
      if (targetAngleY>quaternion.y) {
        dAngleY=abs(dAngleY);
      } else {
        dAngleY=-abs(dAngleY);
      }
      quaternion.y+=dAngleY;
    }
  }

  void draw() {
    pushMatrix();
    pushStyle();
    translate(pos);
    rotate(quaternion);
    render();
    popStyle();
    popMatrix();
  }
}


/*A FoodObject is a GameObject (navigable overworld object) that represents a Food.*/
class FoodObject extends GameObject {

  final int ON_TIME=60;
  FoodObjectData data;
  int onTimer;

  FoodObject(PVector pos, PVector dim, float parentTranslationX, float parentTranslationZ, float triggerRadius, PVector quaternion, FoodObjectData data) {
    super(pos, dim, parentTranslationX, parentTranslationZ, triggerRadius, quaternion);
    this.data=data;
    onTimer=(int)random(1, ON_TIME*2);
  }

  FoodObjectData getFoodData() {
    return data;
  }

  void render() {

    if (onTimer>ON_TIME) {
      image(data.getImage(), -dim.x/2, -dim.y*2);
    } 
    onTimer--;
    if (onTimer==0) {
      onTimer=ON_TIME*2;
    }
  }

  void handleCollisionWithPlayer() {
    modeTransitioner.encounteredFood(this);
  }
}

//a collectible jewel
class Jewel extends GameObject {

  color fill;
  int faces;
  float faceTheta=PI/4;

  Jewel(PVector pos, PVector dim, float parentTranslationX, float parentTranslationZ, float triggerRadius, PVector quaternion) {
    super(pos, dim, parentTranslationX, parentTranslationZ, triggerRadius, quaternion);
    float rand=random(1);
    fill=(rand<.15? color(255, 0, 0): rand<.3? color(0, 255, 0) : rand<.6?color(0, 0, 255): rand<.9? color(255, 255, 0) : color(225, 0, 255));
    faces=(int)(TWO_PI/faceTheta);
  }

  void update() {
    super.update();
    //rotate clockwise slowly
    quaternion.y+=.02;
  }

  void render() {

    noStroke();
    rotateZ(PI/4);

    for (int i=0; i<faces; i++) {
      fill(red(fill)/(i+1), green(fill)/(i+1), blue(fill)/(i+1));
      rotateY(faceTheta);
      rect(-dim.x/2, -dim.y*2, dim.x, dim.y);
    }
  }

  void handleCollisionWithPlayer() {
    jewelsCollected++;
  }
}


class ConcernTrigger extends GameObject {
  ConcernTrigger(PVector pos, PVector dim, float parentTranslationX, float parentTranslationZ, float triggerRadius, PVector quaternion) {
    super(pos, dim, parentTranslationX, parentTranslationZ, triggerRadius, quaternion);
  }

  void handleCollisionWithPlayer() {
    //overWorld.activateConcernEvent();
    //it should also tell the gameworld to create a quest that is somehow linked to this concern and put it in the same place where the concern was
  }

  void render() {
    fill(255);
    rect(-dim.x/2, -dim.y*2, dim.x, dim.y);
  }
}